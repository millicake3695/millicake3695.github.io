---
title: 正则表达式
categories:
 - frontEnd
tags:
 - JS
 - RegExp
---

<!-- more -->



  [Regular Expressions](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)

  正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、matchAll、replace、search 和 split 方法。

  [延伸阅读](https://juejin.im/post/5965943ff265da6c30653879)

### 特殊字符

  ⚠️ 此处特殊字符的含义仅列举部分。

  <div style="width:100px">字符</div>       |含义
  --|:--
  `^`       |匹配输入的开始
  `$`       |匹配输入的结束
  `*`       |匹配前一个表达式 0 次或多次。等价于 `{0,}`。
  `+`       |匹配前面一个表达式 1 次或者多次。等价于 `{1,}`。
  `?`       |匹配前面一个表达式 0 次或者 1 次。等价于 `{0,1}`。如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。
  `.`       |默认匹配除换行符之外的任何单个字符。
  `(x)`     |匹配 x 并且记住匹配项。其中括号被称为捕获括号。
  `(?:x)`   |匹配 x 但是不记住匹配项。这种括号叫作非捕获括号。
  `x(?=y)`  |匹配 x 仅仅当 x 后面跟着 y 。这种叫做先行断言。
  `x(?!y)`  |仅仅当 x 后面不跟着 y 时匹配 x ，这被称为正向否定查找。
  `(?<=y)x` |匹配 x 仅当 x 前面是 y 。这种叫做后行断言。js不支持
  `(?<!y)x` |仅仅当 x 前面不是 y 时匹配 x ，这被称为反向否定查找。js不支持
  `x|y`     |匹配 x 或者 y。
  `{n,}`    |n是一个正整数，匹配前一个字符至少出现了n次。
  `[xyz]`   |一个字符集合。
  `\b`      |匹配一个词的边界。
  `\B`      |匹配一个非单词边界。
  `\d`      |匹配一个数字。
  `\D`      |匹配一个非数字字符。等价于`[^0-9]`。
  `\w`      |匹配一个单字字符（字母、数字或者下划线）。等价于 `[A-Za-z0-9_]`。
  `\W`      |匹配一个非单字字符。等价于 `[^A-Za-z0-9_]`。
  `\0`      |匹配 NULL（U+0000）字符， 不要在这后面跟其它小数，因为 `\0<digits>` 是一个八进制转义序列。

### 插入语

  任何正则表达式的插入语都会使这部分匹配的副字符串被记忆。一旦被记忆，这个副字符串就可以被调用于其它用途，如同 [使用括号的子字符串匹配](#使用括号的子字符串匹配) 之中所述。

  但是`(?:)`这种模式匹配的子字符串将不会被记住。比如`(?:\d+)`匹配一次或多次数字字符，但是不能记住匹配的字符。

### 使用括号的子字符串匹配

  一个正则表达式模式使用括号，将导致相应的子匹配被记住。例如`/a(b)c/`可以匹配字符串`abc`，并且记得`b`。回调这些括号中匹配的子串，使用数组元素`[1],……[n]`。

  使用括号匹配的子字符串的数量是`无限`的。返回的数组中保存所有被发现的子匹配。下面的脚本使用`replace()`方法来转换字符串中的单词。在匹配到的替换文本中，脚本使用替代的`$1`，`$2`表示第一个和第二个括号的子字符串匹配。

  ```js
  var re = /(\w+)\s(\w+)/;
  var str = "John Smith";
  var newstr = str.replace(re, "$2, $1"); // Smith, John
  ```

### 方法

  方法|描述
  --|:--
  `exec`|一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。
  `test`|一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。
  `match`|一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。
  `matchAll`|一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。
  `search`|一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。
  `replace`|一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。
  `split`|一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。

  当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用 test 或 search 方法；想得到更多的信息（但是比较慢）则可以使用 exec 或 match 方法。如果你使用exec 或 match 方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象（详见下）。如果匹配失败，那么 exec 方法返回 null（也就是false）。
    
### 案例

  (1) 任意匹配均为false: `/.^/`

  (2) 回溯(使用已记录的匹配值), 构造函数的全局属性`$1`至`$9`
  
  `/\d{4}(-|\/|\.)\d{2}\1\d{2}/.test('2020-08/11')`  `false`

  ⚠️ \1表示引用之前的那个分组`(-|\/|\.)`。不管它匹配到什么（比如-），\1都匹配那个同样的具体某个字符。类似的还有\2, \3, ..., \9

  ```js
  var re = /^((\d)(\d(\d)))\1\2\3\4$/; // 匹配10位数字
  console.log( '1231231233'.test(string) ); // true
  console.log( RegExp.$1 ); // 123
  console.log( RegExp.$2 ); // 1
  console.log( RegExp.$3 ); // 23
  console.log( RegExp.$4 ); // 3

  /<([^>]+)>[\d\D]*<\/\1>/.test('<div>wrong!</p>'); // false 匹配双标签

  re = /(\d{4})-(\d{2})-(\d{2})/;
  '2020-08-10'.replace(re, '$2/$3/$1'); // `10/08/2020`
  console.log( RegExp.$1 ); // 2020
  ```

  (3) 先行断言、非捕获匹配
  
  ```js
  'ababa abbb ababab'.match(/(ab)+/g); // 捕获分组 ['abab', 'ab', 'ababab']
  'ababa abbb ababab'.match(/(?:ab)+/g); // 非捕获分组 ['abab', 'ab', 'ababab']

  '1234567890'.replace(/(\d)(?=(?:\d{3})+$)/g, "$1,"); // '1,234,567,890'
  '1234567890'.match(/(\d)(?=(?:\d{3})+$)/g); // ['1', '4', '7']

  '1234567890.99'.replace(/\B(?=(?:\d{3})+(?!\d))/g, ','); // '1,234,567,890.99'
  '1234567890.99'.match(/\B(?=(?:\d{3})+(?!\d))/g); // ['', '', '']
  ```

  (4) 正向肯定(否定)查找

  ```js
  // (?:a) 非捕获匹配 表示匹配a本身 可以避免浪费内存。
  // b(?=a) 非捕获匹配 正向肯定查找 匹配任何其后紧接a的字符串
  // b(?!a) 非捕获匹配 正向否定查找 匹配任何其后没有紧接a的字符串
  // (?<=a)b 非捕获匹配 反向肯定查找 匹配任何其前紧接a的字符串
  // (?<!a)b 非捕获匹配 反向否定查找 匹配任何其前没有紧接a的字符串
  let $ = '$';
  let a = 'happy happily'.replace(/happ(?=ily)/, $); // happy $ily 前向查找
  let b = 'happy happily'.replace(/happ(?!ily)/, $); // $y happily 前向负查找
  let c = 'happy happily'.replace(/happ(?:ily)/, $); // happy $
  // let d = 'apple people'.replace(/(?<=ap)ple/, $); // ap$ people 后向查找 javascript不支持
  // let e = 'apple people'.replace(/(?<!ap)ple/, $); // $y happily 后向负查找 javascript不支持
  let d = 'apple people'
          .split('').reverse().join('')
          .replace(/elp(?=pa)/, $)
          .split('').reverse().join(''); // ap$ people
  let e = 'apple people'
          .split('').reverse().join('')
          .replace(/elp(?!pa)/, $)
          .split('').reverse().join(''); // apple peo$
  ```
